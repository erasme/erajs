
Liste de choses à faire:
------------------------

* - renommer Era.* par Core.* pour le coeur du système
* - renommer Era.* par Ui.* pour les éléments d'interface
    graphique
* - Créer une classe ButtonBase dont hérite les bouttons
    cette classe doit gérer l'évènement "pressed" et la gestion
    du curseur souris
* - Créer Button qui hérite de ButtonBase et fait un rendu
    "classic" d'un bouton (Pressable)
* - Dans scrollingarea permettre de desactiver la fonction
    de scrolling en vertical ou en horizontal. Dans ce cas,
    la scrolling area réclame l'espace nécessaire pour les
    enfants en vertical ou horizontal.
* - Virer le code de positionnement de Ui.Container ainsi
    que la gestion du padding (à déplacer dans VBox, HBox, LBox)
* - Créer LBox pour remplacer la logique de positionnement par
    couche de Ui.Container
* - Créer Ui.DropBox pour les destinations de Drag & Drop

- Créer Ui.DragElement pour les sources de Drag & Drop

* - Créer Ui.IconList et Ui.IconListItem pour le rendu des
    listes en icone

* - Revoir "disconnect". Si on connect plusieurs callback
    le disconnect ne permet pas de préciser celui que l'on enlève.
    A tester.

x - Remplacer VBox, HBox et LBox par StackPanel avec le choix du mode

* - Proposer une option "autoscale" pour les App

* - Dans l'Accordeon, cacher les éléments (avec display: none) lorsqu'ils
    ne sont plus du tout visible. Cela devrait permettre de gagner des ressources

- Dans Ui.App, ne plus utiliser append, fournir une méthode setContent

- Dans Ui.App, permettre de fournir un dépôt de police de caractère. Les éléments
  texte comme Label et Text doivent utiliser ce dépôt pour charger la police
  et recalculer la taille du texte lorsqu'elle est disponible

- Dans Ui.Container, fournir des fonctions pour réordonner les fils
  et une fonction pour remplacer un element par un autre

* - Dans le système d'animation, voir si on peut pas finalement se débarrasser
    des timelines pour n'utiliser que les clock

* - Changer la gestion de updateRender. invalidateRender doit créer une liste chainée
    rattaché à Ui.App.current qui l'on parcours dans update

- invalidateMeasure doit informer le parent mais le parent doit
  pouvoir ou pas faire suivre a son parent. Passer donc par une methode
  que l'on peut surcharger pour gérer cela

- implementer un Togglable

* - Fournir l'accès aux box-shadow dans Ui.Rectangle

- Fournir un système de gestion des styles (sous forme
  de JSON)

- Fournir un ToolBarButton

- Fournir un ButtonBox + HButtonBox + VButtonBox (et inserer
  des éléments dedans)

- Virer le parametre "force" de arrange de measure

- Gérer un état "disable" que l'on hérite. Cela doit nous
  permettre de rendre inactive n'importe qu'elle arborescence

- voir pour intégrer les animations dans le "update" de Ui.App
  (ordre logique: event, anim, render, measure, arrange)

* - dans Ui.Fold, utiliser display: none lorsque la partie cachée est
    cachée (pas display: none mais visibility: hidden sinon on ne peut
    plus mesuré le texte)

- dans Ui.Scrollable envoyer systématiquement comme taille minimum
  la taille de barre de scroll

- dans Ui.App update, gérer la mise à jour de l'arbre de rendu
  d'abords et le rendu graphique à la fin (en gros, séparer
  l'updateRender en 2)

* - dans Accordeon, utiliser offset entre 0-1 (en relatif) pour
    pouvoir gérer correctement le redimentionnement

- lorsqu'un Ui.Element Focusable est disabled, il ne doit plus
  être accessible au focus et doit même le perdre s'il l'avait

- dans Ui.Button, fournir une propriété "variant" ou "ui"
  pour proposer différents "style" de bouton comme:
  - normal
  - normal-left
  - normal-right
  - normal-middle
  - toolbar
  - toolbar-left
  - toolbar-right
  - toolbar-middle

- Proposer un style différent pour les menus, les dialogs
  style que les menus et les dialogs appliqueront aux éléments
  enfants (avec les propriétés génériques: background, spacing...)

* - pour Ui.Rectangle, supprimer un niveau de div. Modifier le drawing
    pour l'affichage.

- pour Ui.Color faire un parser pour #rgb #rrggbb rgb(r,g,b) rgba(r,g,b,a)
  dans Ui.Color.create

- a verifier le comportement de measure dans Box pour les Uniform
  (la contrainte doit faire au plus petit possible)

